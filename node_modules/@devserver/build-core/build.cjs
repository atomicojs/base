'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var path = require('path');
var promises = require('fs/promises');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var path__default = /*#__PURE__*/_interopDefaultLegacy(path);

/**
 * Generates a hash based on [anteesor, current, successor]
 * @param {string|string[]} str
 * @returns {string}
 */
function hash(str) {
    let total = [0, 0, 0];
    let length = str.length;
    while (length--) {
        total[0] += getValue(str[length - 1]);
        total[1] += getValue(str[length]);
        total[2] += getValue(str[length + 1]);
    }
    return total.map((value) => value.toString(16)).join("-");
}

const getValue = (value) => (value ? value.charCodeAt() : 0);

const cacheDir = {};
/**
 *
 * @param {string} dir
 */
const prepareDir = (dir) => {
    const dirname = pathname(dir).replace(/(\/){0,1}[^\/]+\.\w+$/, "");
    return (cacheDir[dirname] =
        cacheDir[dirname] || promises.mkdir(dirname, { recursive: true }));
};
/**
 *
 * @param {string} dir
 */
const pathname = (dir) => dir.replace(/[\\\/]+/g, "/");

const cwd = process.cwd();

class Build {
    /**
     * Virtual files stored by the build
     * @type{Object<string,Ref>}
     */
    output = {};
    /**
     * Task queue
     * @type{Promise<any>[]}
     */
    task = [];
    /**
     *
     * @param {Object} options
     * @param {string} [options.href] - prefix to add to static file path reference
     * @param {string} [options.base] - base directory, limits the mayor reading files and resolutions
     * @param {string} [options.dest] - prefix to add to static file path reference
     * @param {string} [options.cwd] - prefix to add to static file path reference
     * @param {boolean} [options.minify] - declare file minification for plugins
     * @param {boolean} [options.sourcemap] - declares the generation of source maps for the files
     * @param {Plugin[]} plugins
     */
    constructor(options, plugins = []) {
        this.options = options;
        this.plugins = plugins;
        this.regBase = RegExp("^(\\./){0,1}" + options.base);
    }
    /**
     * resolve a file under the build context
     * @param {string} from
     * @param {string} to
     */
    resolve = (from, to) => {
        return (
            "./" +
            pathname(
                path__default['default'].join(
                    to[0] == "/" ? this.options.base : path__default['default'].dirname(from),
                    to
                )
            )
        );
    };
    /**
     * Create a link object
     * @param {string} id
     * @param {boolean} [asset]
     * @returns {Link}
     */
    link = (id, asset) => {
        const self = this;
        return {
            root: pathname("/" + id),
            get name() {
                return asset
                    ? hash(id) +
                          path__default['default'].extname(id).replace(/\.(jsx|ts|tsx)$/, ".js")
                    : path__default['default'].basename(id);
            },
            get href() {
                return pathname([self.options.href, this.dest].join("/"));
            },
            get dest() {
                return pathname(
                    asset
                        ? "assets/" + this.name
                        : pathname(id).replace(self.regBase, "")
                );
            },
        };
    };
    /**
     * load a file to the plugin queue
     * @param {string} id
     * @param {boolean} [asset]
     */
    load = (id, asset) => {
        const ref = this.set(id, {
            asset,
            load: (ref) =>
                this.plugins
                    .filter((plugin) => plugin.filter && plugin.filter(id))
                    .reduce(
                        (pipe, plugin) =>
                            plugin.load
                                ? pipe.then(() => plugin.load(ref, this))
                                : pipe,
                        Promise.resolve()
                    ),
        });

        if (ref.task) {
            this.task.push(ref.task);
        }

        return ref;
    };
    /**
     * Add the file to a resolution queue and return its reference
     * @param {string} id
     * @param {Object} options
     * @param {boolean} [options.copy]
     * @param {boolean} [options.asset]
     * @param {(ref:Ref)=>Promise<any>} [options.load]
     * @returns {Ref}
     */
    set = (id, { copy, asset, load } = {}) => {
        id = path__default['default'].relative(this.options.cwd || cwd, id);
        if (!this.output[id]) {
            this.output[id] = this.ref(id, {
                copy,
                asset,
            });
        }

        const ref = this.output[id];

        if (!ref.task && load) {
            ref.task = load(ref);
        }

        return ref;
    };
    /**
     * Create a file reference without association to the output
     * @param {string} id
     * @param {{asset?:boolean,copy?:boolean}} [options]
     * @returns {Ref}
     */
    ref = (id, { asset, copy } = {}) => {
        return {
            id,
            copy,
            asset,
            link: this.link(id, asset),
            /**
             *
             * @param {string} to
             */
            resolve: (to) => this.resolve(id, to),
            read: () => promises.readFile(id, "utf8"),
        };
    };
    /**
     * Wait for the resolution of the tasks and
     * clean the already expected ones
     */
    waitTaskCycle = () => {
        const { task } = this;
        if (!task.length) return;
        this.task = [];
        return Promise.all(task).then(this.waitTaskCycle);
    };
    /**
     * Internal, allows to dispatch the plugin.loaded hook
     */
    buildEnd = async () => {
        await this.waitTaskCycle();
        /**
         * Execute the hook loaded in parallel
         */
        await Promise.all(
            this.plugins.map((plugin) => plugin.loaded && plugin.loaded(this))
        );

        await this.waitTaskCycle();
    };
    /**
     * Write the build files to disk
     */
    writeOutput = async () => {
        await this.buildEnd();
        const { output } = this;
        const { options } = this;
        return Promise.all([
            ...Object.keys(output)
                .map((id) => output[id])
                .map(async ({ id, copy, code, link, map }) => {
                    const fileDest = path__default['default'].join(options.dest, link.dest);
                    await prepareDir(fileDest);
                    /**
                     * @type {Promise<any>[]}
                     */
                    const task = [];
                    if (
                        options.sourcemap &&
                        map &&
                        !/sourceMappingURL=/.test(code)
                    ) {
                        code += `//# sourceMappingURL=${link.name}.map`;
                        task.push(
                            promises.writeFile(fileDest + ".map", map + "", "utf8")
                        );
                    }
                    task.push(
                        copy
                            ? promises.copyFile(id, fileDest)
                            : code != null && promises.writeFile(fileDest, code, "utf8")
                    );
                    return Promise.all(task);
                }),
        ]);
    };
}

/**
 * @typedef {Object} Link
 * @property {string} root
 * @property {string} name
 * @property {string} href
 * @property {string} dest
 */

/**
 * @typedef {Object} Ref
 * @property {string} id
 * @property {string} [code]
 * @property {any} [map]
 * @property {boolean} [copy]
 * @property {boolean} [asset]
 * @property {Link} link
 * @property {(to:string)=>string} resolve
 * @property {Promise<any>} [task]
 * @property {()=>Promise<string>} read
 */

/**
 * @callback Filter
 * @param {string} id
 */

/**
 * @callback Load
 * @param {Ref} ref
 * @param {Build} build
 */

/**
 * @callback Loaded
 * @param {Build} build
 */

/**
 * @typedef {Object} Plugin
 * @property {Filter} [filter]
 * @property {Load} [load]
 * @property {Loaded} [loaded]
 * @property {any} [data]
 */

exports.Build = Build;
